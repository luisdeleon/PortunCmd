<script setup lang="ts">
import { VForm } from 'vuetify/components/VForm'
import { supabase } from '@/lib/supabase'

const { t } = useI18n({ useScope: 'global' })

interface PropertyData {
  id?: string
  name: string
  address: string
  community_id: string
}

interface Props {
  propertyData?: PropertyData
  isDialogVisible: boolean
}

interface Emit {
  (e: 'update:isDialogVisible', value: boolean): void
  (e: 'property-saved'): void
}

const props = withDefaults(defineProps<Props>(), {
  propertyData: () => ({
    name: '',
    address: '',
    community_id: '',
  }),
})

const emit = defineEmits<Emit>()

const refPropertyForm = ref<VForm>()
const isSaving = ref(false)
const isEditMode = ref(false)

// Property ID validation state
const isCheckingId = ref(false)
const idAlreadyExists = ref(false)
const idCheckDebounceTimer = ref<ReturnType<typeof setTimeout> | null>(null)

// Form data
const propertyForm = ref<PropertyData>({
  id: '',
  name: '',
  address: '',
  community_id: '',
})

// Communities list
const communities = ref<Array<{ title: string; value: string; communityId: string }>>([])
const isLoadingCommunities = ref(false)

// Track the last auto-generated ID to know if user modified it
const lastAutoGeneratedId = ref('')

// Get selected community ID prefix
const selectedCommunityPrefix = computed(() => {
  const selected = communities.value.find(c => c.value === propertyForm.value.community_id)
  return selected?.communityId || ''
})

// Fetch communities
const fetchCommunities = async () => {
  try {
    isLoadingCommunities.value = true

    const { data, error } = await supabase
      .from('community')
      .select('id, name')
      .order('name')

    if (error) {
      console.error('Error fetching communities:', error)
      return
    }

    communities.value = data?.map(community => ({
      title: `${community.id}${community.name ? ' - ' + community.name : ''}`,
      value: community.id,
      communityId: community.id,
    })) || []
  } catch (err) {
    console.error('Error in fetchCommunities:', err)
  } finally {
    isLoadingCommunities.value = false
  }
}

// Generate a 3-character code from property name
const generateCodeFromName = (name: string | null | undefined): string => {
  if (!name || !name.trim()) return ''

  // Remove special characters, accents, and normalize
  const cleanName = name
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remove accents
    .toUpperCase()
    .replace(/[^A-Z0-9\s]/g, '') // Keep only letters, numbers and spaces
    .trim()

  // Check if it starts with numbers (like "101", "25A")
  const numberMatch = cleanName.match(/^(\d+)/)
  if (numberMatch) {
    // Pad number to 3 digits or take first 3 chars if longer
    const num = numberMatch[1]
    if (num.length >= 3) return num.slice(0, 3)
    return num.padStart(3, '0')
  }

  const words = cleanName.split(/\s+/).filter(w => w.length > 0)

  if (words.length === 0) return ''

  let letters = ''

  if (words.length === 1) {
    // Single word: take first 3 characters
    letters = words[0].slice(0, 3)
  } else if (words.length === 2) {
    // Two words: take first 2 chars from first, first 1 from second
    letters = words[0].slice(0, 2) + words[1].slice(0, 1)
  } else {
    // Three or more words: take first character from each of first 3 words
    letters = words.slice(0, 3).map(w => w[0]).join('')
  }

  // Pad with additional letters if less than 3
  while (letters.length < 3) {
    for (const word of words) {
      if (letters.length >= 3) break
      for (let i = 0; i < word.length && letters.length < 3; i++) {
        if (!letters.includes(word[i]) || letters.length < 3) {
          letters += word[i]
        }
      }
    }
    if (letters.length < 3) letters += 'X'
  }

  return letters.slice(0, 3)
}

// Generate full property ID: CommunityID + PropertyCode
const generatePropertyId = (): string => {
  const prefix = selectedCommunityPrefix.value
  const code = generateCodeFromName(propertyForm.value.name)

  if (!prefix || !code) return ''

  return `${prefix}-${code}`
}

// Watch for community or name changes to auto-generate ID
watch([() => propertyForm.value.community_id, () => propertyForm.value.name], () => {
  if (!isEditMode.value) {
    const currentId = propertyForm.value.id?.trim() || ''
    const shouldGenerate = currentId === '' || currentId === lastAutoGeneratedId.value

    if (shouldGenerate) {
      const generatedId = generatePropertyId()
      propertyForm.value.id = generatedId
      lastAutoGeneratedId.value = generatedId
    }
  }
})

// Check if property ID already exists in database
const checkPropertyIdExists = async (id: string): Promise<boolean> => {
  if (!id.trim()) return false

  const { data, error } = await supabase
    .from('property')
    .select('id')
    .eq('id', id.trim())
    .maybeSingle()

  if (error) {
    console.error('Error checking property ID:', error)
    return false
  }

  return !!data
}

// Watch property ID changes to check for duplicates (debounced)
watch(() => propertyForm.value.id, (newId) => {
  // Clear previous timer
  if (idCheckDebounceTimer.value) {
    clearTimeout(idCheckDebounceTimer.value)
  }

  // Reset state if empty or in edit mode
  if (!newId?.trim() || isEditMode.value) {
    idAlreadyExists.value = false
    isCheckingId.value = false
    return
  }

  // Start checking indicator
  isCheckingId.value = true
  idAlreadyExists.value = false

  // Debounce the check (500ms)
  idCheckDebounceTimer.value = setTimeout(async () => {
    const exists = await checkPropertyIdExists(newId)
    idAlreadyExists.value = exists
    isCheckingId.value = false
  }, 500)
})

// Watch for dialog visibility to populate form
watch(() => props.isDialogVisible, (newVal) => {
  if (newVal) {
    // Fetch communities when dialog opens
    fetchCommunities()

    // Determine if we're in edit mode based on whether propertyData has an id
    isEditMode.value = !!(props.propertyData?.id)

    if (props.propertyData?.id) {
      // Edit mode - populate form with existing data
      propertyForm.value = { ...props.propertyData }
    } else {
      // Create mode - reset to empty form
      resetForm()
      isEditMode.value = false
    }
  } else if (!newVal) {
    // Reset form when dialog closes
    resetForm()
  }
})

const resetForm = () => {
  // Clear debounce timer if active
  if (idCheckDebounceTimer.value) {
    clearTimeout(idCheckDebounceTimer.value)
    idCheckDebounceTimer.value = null
  }

  propertyForm.value = {
    id: '',
    name: '',
    address: '',
    community_id: '',
  }
  isEditMode.value = false
  isCheckingId.value = false
  idAlreadyExists.value = false
  lastAutoGeneratedId.value = ''
  refPropertyForm.value?.reset()
}

const onSubmit = async () => {
  const { valid } = await refPropertyForm.value!.validate()

  if (!valid) return

  // Prevent submission if ID already exists or is still being checked
  if (idAlreadyExists.value || isCheckingId.value) return

  try {
    isSaving.value = true

    // Check if we're editing or creating
    if (isEditMode.value) {
      // Update existing property
      const { error } = await supabase
        .from('property')
        .update({
          name: propertyForm.value.name,
          address: propertyForm.value.address,
          community_id: propertyForm.value.community_id,
        })
        .eq('id', propertyForm.value.id)

      if (error) throw error
    } else {
      // Create new property - use provided ID or generate one
      const propertyId = propertyForm.value.id?.trim() || crypto.randomUUID()

      const { error } = await supabase
        .from('property')
        .insert({
          id: propertyId,
          name: propertyForm.value.name,
          address: propertyForm.value.address,
          community_id: propertyForm.value.community_id,
        })

      if (error) throw error
    }

    // Success
    emit('property-saved')
    emit('update:isDialogVisible', false)
    resetForm()
  } catch (err: any) {
    console.error('Error saving property:', err)
    alert(`Failed to save property: ${err.message}`)
  } finally {
    isSaving.value = false
  }
}

const onReset = () => {
  emit('update:isDialogVisible', false)
  resetForm()
}

// Force uppercase on Property ID input
const onPropertyIdInput = (event: Event) => {
  const input = event.target as HTMLInputElement
  const upperValue = input.value.toUpperCase().replace(/[^A-Z0-9-]/g, '')
  propertyForm.value.id = upperValue
}

// Validation rules
const requiredRule = (v: string) => !!v || t('propertyDialog.validation.required')

// Property ID validation rule
const propertyIdRule = () => {
  if (idAlreadyExists.value) {
    return t('propertyDialog.validation.idAlreadyExists')
  }
  return true
}
</script>

<template>
  <VDialog
    :width="$vuetify.display.smAndDown ? 'auto' : 700"
    :model-value="props.isDialogVisible"
    @update:model-value="onReset"
  >
    <!-- Dialog close btn -->
    <DialogCloseBtn @click="onReset" />

    <VCard class="pa-sm-10 pa-2">
      <VCardText>
        <!-- Title -->
        <div class="text-center mb-6">
          <VAvatar
            size="88"
            color="success"
            variant="tonal"
            class="mb-4"
          >
            <VIcon
              icon="tabler-home"
              size="48"
            />
          </VAvatar>
          <h4 class="text-h4 mb-2">
            {{ isEditMode ? t('propertyDialog.editTitle') : t('propertyDialog.addTitle') }}
          </h4>
          <p class="text-body-1 text-medium-emphasis">
            {{ isEditMode ? t('propertyDialog.editSubtitle') : t('propertyDialog.addSubtitle') }}
          </p>
        </div>

        <!-- Form -->
        <VForm ref="refPropertyForm">
          <VRow>
            <!-- Community Section (First) -->
            <VCol cols="12">
              <div class="d-flex align-center gap-2 mb-3">
                <VIcon
                  icon="tabler-building-community"
                  size="20"
                  color="success"
                />
                <h6 class="text-h6 text-success">
                  {{ t('propertyDialog.sections.communityAssignment') }}
                </h6>
              </div>
            </VCol>

            <!-- Community Selection (Required) -->
            <VCol cols="12">
              <VAutocomplete
                v-model="propertyForm.community_id"
                :items="communities"
                :loading="isLoadingCommunities"
                :label="t('propertyDialog.fields.community')"
                :placeholder="t('propertyDialog.fields.communityPlaceholder')"
                :rules="[requiredRule]"
                clearable
                clear-icon="tabler-x"
                auto-select-first
              >
                <template #prepend-inner>
                  <VIcon icon="tabler-building-community" />
                </template>
              </VAutocomplete>
              <div class="text-caption text-medium-emphasis mt-1">
                <VIcon
                  icon="tabler-info-circle"
                  size="16"
                  class="me-1"
                />
                {{ t('propertyDialog.fields.communityHint') }}
              </div>
            </VCol>

            <!-- Basic Information Section -->
            <VCol cols="12">
              <VDivider class="my-2" />
              <div class="d-flex align-center gap-2 mb-3 mt-4">
                <VIcon
                  icon="tabler-info-circle"
                  size="20"
                  color="primary"
                />
                <h6 class="text-h6 text-primary">
                  {{ t('propertyDialog.sections.basicInfo') }}
                </h6>
              </div>
            </VCol>

            <!-- Property Name -->
            <VCol cols="12">
              <AppTextField
                v-model="propertyForm.name"
                :label="t('propertyDialog.fields.propertyName')"
                :placeholder="t('propertyDialog.fields.propertyNamePlaceholder')"
                :rules="[requiredRule]"
              >
                <template #prepend-inner>
                  <VIcon icon="tabler-home" />
                </template>
              </AppTextField>
            </VCol>

            <!-- Address -->
            <VCol cols="12">
              <AppTextField
                v-model="propertyForm.address"
                :label="t('propertyDialog.fields.address')"
                :placeholder="t('propertyDialog.fields.addressPlaceholder')"
                :rules="[requiredRule]"
              >
                <template #prepend-inner>
                  <VIcon icon="tabler-map-2" />
                </template>
              </AppTextField>
            </VCol>

            <!-- Property ID (only for new properties) -->
            <VCol
              v-if="!isEditMode"
              cols="12"
            >
              <AppTextField
                v-model="propertyForm.id"
                :label="t('propertyDialog.fields.propertyId')"
                :placeholder="t('propertyDialog.fields.propertyIdPlaceholder')"
                :hint="isCheckingId ? t('propertyDialog.validation.checkingId') : t('propertyDialog.fields.propertyIdHint')"
                :error="idAlreadyExists"
                :error-messages="idAlreadyExists ? t('propertyDialog.validation.idAlreadyExists') : undefined"
                :loading="isCheckingId"
                :rules="[propertyIdRule]"
                persistent-hint
                @input="onPropertyIdInput"
              >
                <template #prepend-inner>
                  <VIcon icon="tabler-hash" />
                </template>
                <template
                  v-if="isCheckingId"
                  #append-inner
                >
                  <VProgressCircular
                    size="20"
                    width="2"
                    indeterminate
                    color="primary"
                  />
                </template>
                <template
                  v-else-if="propertyForm.id && !idAlreadyExists"
                  #append-inner
                >
                  <VIcon
                    icon="tabler-check"
                    color="success"
                  />
                </template>
              </AppTextField>
            </VCol>
          </VRow>

          <!-- Action buttons -->
          <VRow class="mt-8">
            <VCol
              cols="12"
              sm="6"
              order="2"
              order-sm="1"
            >
              <VBtn
                color="secondary"
                variant="outlined"
                :disabled="isSaving"
                prepend-icon="tabler-x"
                size="large"
                block
                @click="onReset"
              >
                {{ t('propertyDialog.buttons.cancel') }}
              </VBtn>
            </VCol>
            <VCol
              cols="12"
              sm="6"
              order="1"
              order-sm="2"
            >
              <VBtn
                color="success"
                :loading="isSaving"
                :disabled="isSaving || isCheckingId || idAlreadyExists"
                prepend-icon="tabler-check"
                size="large"
                block
                @click="onSubmit"
              >
                {{ isSaving ? t('propertyDialog.buttons.saving') : (isEditMode ? t('propertyDialog.buttons.update') : t('propertyDialog.buttons.create')) }}
              </VBtn>
            </VCol>
          </VRow>
        </VForm>
      </VCardText>
    </VCard>
  </VDialog>
</template>
